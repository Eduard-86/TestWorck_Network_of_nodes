#include <iostream>
#include <functional>
#include <vector>
#include <map>
#include "Notework_manager.h"
#include <windows.h>

/*
Читается неплохо, хорошо
Оформления заголовков хворает, но код читается внятно
Английский учить конеш надо, или больше переводчиком пользоваться

имена переменных периодически хворают

Не пренебрегай const квалификаторами на локальных переменных
Они больше нужны читающему, чем компилятору, но компилятору тоже не помешают - порой может отчебучить без них на ровном месте

Больше выноси методов
Чтобы все читалось как тик менеджера
Похуй что метод используется всего в одном месте - прочитать несколько слов естественного языка в хулиард раз проще чем даже столько же слов упрощенного машинного языка
То же касается типов - лучше затайпдефить если используется даже больше одного раза
То же касается вычислений - и математических и логических - выноси элементы в локальные перменные с понятными именами - компилятор ебнет все лишнее, а читаться будет гораздо лучше

Читаемость так же повышается assume-ами - через них можно явно описывать какое состояние системы ты сейчас ожидаешь. В анриле используется их усоврешенствованая версия - check-и

Много опечаток

Проебалась кодировка - хз почему, мне влом чинить, соответсвенно не запускаю, хотя собирается

Проебал атомарность тика
до конца отдельно взятого тика ни у одной ноды не может измениться ни одно число подписок
все действия внутри тика должны происходить без учета всех других действий которые уже были совершены или будут совершены
как будто все случилось одновременно

странный мехнизм с подписками
bool стоит как индикатор метода
а если методов будет 100 а не 2?
заменишь на инт?
а зачем он там вообще?
даже если в чисто диагностических целях, то его сейчас нельзя просто взять и выбросить по щелчку пальца, а диагностика должна работать именно так

размещать ввод с клавы в конструкторе класса - азаза
я понимаю что здесь конкретно можно, но лучше не надо
крайне невежливо так делать

нахуя тела методов менджера в заголовочном файле прописал?

за содержимое деструктора ноды полагается 10 расстрелов вне очереди

мультикаст делегат можно было бы вынести в отдельный класс

в целом неплохо
ощущение что старался
но немного не туда
но по неопытности
пара мутных моментов
ну и опуская факт что прикол с атомарностью тика проебан
без б, в разы лучше конечно чем все что кидал коля когда устраивался
 */

using namespace std;

class Class
{
public:
    int value;

    Class(int a) : value(a)
    {
        cout << value << " pricol " << endl;
    }
	~Class()
    {
        cout << value << " pizda " << endl;
    }
};

using std::vector;

void RadixSort(vector<int> array, int k, int length)
{
    vector<int>* temparray = new vector<int>(k);


    for (int i = 0; i < length; ++i)
    {
        int numberval = pow(10, i);
    	
        for (int element : array)
        {
            cout << (element / numberval) % 10 << "\t";
        }
    }
	
}

int main()
{
    //setlocale(LC_ALL, "ru");
	srand(time(NULL));

    vector<int> a;
	
    //vector<int>a()[432, 223, 554, 543, 222];
	
    //RadixSort(vector<int>(){432,223,554,543,222}, );
	
    Notework_manager manager = Notework_manager();

    manager.StartSimulator();

   

	for (int i = 0; i <= 5; ++i)
	{
        manager.Tick();
        Sleep(1000);
	}

    /*
	Notework_manager A();

	
    std::cout << "Hello World!\n";


    vector<Class*> a;

    Class* A1 = new Class(1);
    Class* A2 = new Class(2);
    Class* A3 = new Class(3);
    Class* A4 = new Class(4);
    Class* A5 = new Class(5);

	


	
    a.push_back((A1));
    a.push_back((A2));
    a.push_back((A3));
    a.push_back((A4));
    a.push_back((A5));

    for (int i = a.size() - 1; i > -1; --i)
    {
        cout << a[i]->value << " ";
    }

    cout << endl;
	
    for (int i = a.size() - 1; i > -1; --i)
    {
        if (a[i]->value % 2 != 0)
        {
            cout << " delete - " << a[i]->value << endl;

            //auto del = a.begin() + i;
        	
            a.erase(a.begin() + i);
        }
    }
	
    cout << endl;
	
    for (int i = a.size() - 1; i > -1; --i)
    {
        cout << a[i]->value << " ";
    }
    
    cout << endl;
        */

   
	
}
